<!doctype html>
<meta charset="utf-8">
<script src="http://distill.pub/template.v1.js"></script>

<script type="text/front-matter">
  title: "Understanding the ANS Compressor"
  description: "understanding the Asymmetric Numeral Systems Compressor"
  authors:
  - Kedar Tatwawadi: https://github.com/kedartatwawadi
  affiliations:
  - Stanford University: http://stanford.edu
</script>


<!-- Katex -->
<!--<script src="assets/lib/auto-render.min.js"></script>-->
<!--<script src="assets/lib/katex.min.js"></script>-->
<link rel="stylesheet" href="assets/lib/katex.min.css">
<link rel="stylesheet" type="text/css" href="assets/widgets.css">

<!-- Required -->
<script src="assets/lib/lib.js"></script>
<script src="assets/utils.js"></script>
<script>
  var renderQueue = [];
  function renderMath(elem) {
    // renderMathInElement(
    //     elem,
    //     {
    //         delimiters: [
    //             {left: "$$", right: "$$", display: true},
    //             {left: "$", right: "$", display: false},
    //         ]
    //     }
    // );
  }
  var deleteQueue = [];
  function renderLoading(figure) {
    var loadingScreen = figure.append("svg")
    .style("width", figure.style("width"))
    .style("height", figure.style("height"))
    .style("position","absolute")
    .style("top", "0px")
    .style("left","0px")
    .style("background","white")
    .style("border", "0px dashed #DDD")
    .style("opacity", 1)
    return function(callback) { loadingScreen.remove() };
  }
</script>
<div id="math-cache" style="display: none;">
  <dt-math class="star">\star</dt-math>
  <dt-math class="plus">+</dt-math>
  <dt-math class="minus">-</dt-math>
  <dt-math class="equals">=</dt-math>
  <dt-math class="alpha">\alpha</dt-math>
  <dt-math class="lambda">\lambda</dt-math>
  <dt-math class="beta">\beta</dt-math>
  <dt-math class="r">R</dt-math>
  <dt-math class="alpha-equals">\alpha=</dt-math>
  <dt-math class="beta-equals">\beta=</dt-math>
  <dt-math class="beta-equals-zero">\beta = 0</dt-math>
  <dt-math class="beta-equals-one">\beta=1</dt-math>
  <dt-math class="alpha-equals-one-over-lambda-i">\alpha = 1/\lambda_i</dt-math>
  <dt-math class="model">\text{model}</dt-math>
  <dt-math class="p">0 p_1</dt-math>
  <dt-math class="phat">0 \bar{p}_1</dt-math>
  <dt-math class="two-sqrt-beta">2\sqrt{\beta}</dt-math>
  <dt-math class="lambda-i">\lambda_i</dt-math>
  <dt-math class="lambda-i-equals-zero">\lambda_i = 0</dt-math>
  <dt-math class="alpha-gt-one-over-lambda-i">\alpha > 1/\lambda_i</dt-math>
  <dt-math class="max-sigma-one">\max\{|\sigma_1|,|\sigma_2|\} > 1</dt-math>
  <dt-math class="x-i-k">x_i^k - x_i^*</dt-math>
  <dt-math class="xi-i">\xi_i</dt-math>
  <dt-math class="beta-equals-one-minus">\beta = (1 - \sqrt{\alpha \lambda_i})^2</dt-math>
</div>
<script>
  function MathCache(id) {
    return document.querySelector("#math-cache ." + id).innerHTML;
  }
</script>
<svg style="display: none;">
  <g id="pointerThingy">
    <circle fill="none" stroke="#FF6C00" stroke-linecap="round" cx="0" cy="0" r="14"/>
    <circle fill="#FF6C00" cx="0" cy="0" r="11"/>
    <path id="XMLID_173_" fill="#FFFFFF" d="M-3.2-1.3c0-0.1,0-0.2,0-0.3c0-0.1,0-0.2,0-0.3c-0.6,0-1.2,0-1.8,0c0,0.6,0,1.2,0,1.8
      c0.2,0,0.4,0,0.6,0c0-0.4,0-0.8,0-1.2c0,0,0.1,0,0.1,0c0.3,0,0.5,0,0.8,0C-3.4-1.3-3.3-1.3-3.2-1.3c0,0.2,0,0.4,0,0.6
      c0.2,0,0.4,0,0.6,0c0,0.2,0,0.4,0,0.6c0.2,0,0.4,0,0.6,0c0,0,0,0,0-0.1c0-1.6,0-3.2,0-4.8c0-0.6,0-1.2,0-1.8c0,0,0,0,0.1,0
      c0.3,0,0.7,0,1,0c0.1,0,0.1,0,0.2,0c0-0.2,0-0.4,0-0.6c-0.4,0-0.8,0-1.2,0C-2-7.2-2-7-2-6.8c0,0,0,0-0.1,0c-0.2,0-0.3,0-0.5,0
      c0,0,0,0-0.1,0c0,1.8,0,3.6,0,5.5c-0.2,0-0.3,0-0.4,0C-3.1-1.3-3.2-1.3-3.2-1.3z M1.1-3.7C1-3.8,1-3.8,1.1-3.7C1-4,1-4.1,1-4.3
      c0,0,0,0,0-0.1c-0.4,0-0.8,0-1.2,0c0-0.8,0-1.6,0-2.4c-0.2,0-0.4,0-0.6,0c0,1.8,0,3.6,0,5.5c0.2,0,0.4,0,0.6,0c0-0.8,0-1.6,0-2.4
      c0,0,0.1,0,0.1,0C0.3-3.7,0.6-3.7,1.1-3.7C1-3.7,1-3.7,1.1-3.7C1.1-3.7,1-3.7,1.1-3.7c0,0.8,0,1.6,0,2.3c0,0,0,0.1,0,0.1
      c0.2,0,0.4,0,0.6,0c0-0.6,0-1.2,0-1.8c0.4,0,0.8,0,1.2,0c0,0.8,0,1.6,0,2.4c0.2,0,0.4,0,0.6,0c0-0.6,0-1.2,0-1.8c0.2,0,0.4,0,0.6,0
      c0,0,0,0,0,0.1c0,0.1,0,0.3,0,0.4c0,0,0,0.1,0,0.1c0.2,0,0.4,0,0.5,0c0,0,0.1,0,0.1,0.1c0,0.2,0,0.5,0,0.7c0,1.1,0,2.3,0,3.4
      c0,0,0,0,0,0.1c-0.2,0-0.4,0-0.6,0c0,0,0,0,0,0c0,0.6,0,1.1,0,1.7c0,0,0,0,0,0.1c-0.2,0-0.4,0-0.6,0c0,0.4,0,0.8,0,1.2
      c-1.6,0-3.2,0-4.9,0c0-0.4,0-0.8,0-1.2c-0.2,0-0.4,0-0.6,0C-2,3.8-2,3.4-2,3c-0.2,0-0.4,0-0.6,0c0,0.4,0,0.8,0,1.2
      c0.2,0,0.4,0,0.6,0C-2,4.8-2,5.4-2,6c2,0,4.1,0,6.1,0c0-0.1,0-0.2,0-0.3c0-0.5,0-0.9,0-1.4c0-0.1,0-0.1,0-0.2c0.2,0,0.4,0,0.5,0
      c0.1,0,0.1,0,0.1-0.1c0-0.4,0-0.9,0-1.3c0-0.1,0-0.3,0-0.4c0.1,0,0.2,0,0.3,0c0.1,0,0.2,0,0.3,0c0-1.4,0-2.8,0-4.3
      c-0.2,0-0.4,0-0.6,0c0-0.2,0-0.4,0-0.6c-0.2,0-0.4,0-0.6,0c0-0.2,0-0.4,0-0.6c-0.4,0-0.8,0-1.2,0c0-0.2,0-0.4,0-0.6
      c-0.1,0-0.2,0-0.3,0c-0.4,0-0.9,0-1.3,0C1.2-3.7,1.1-3.7,1.1-3.7z M-3.2,1.8c0,0.4,0,0.8,0,1.2c0.2,0,0.4,0,0.5,0
      c0.1,0,0.1,0,0.1-0.1c0-0.3,0-0.6,0-1c0-0.1,0-0.1,0-0.2C-2.8,1.8-3,1.8-3.2,1.8c0-0.4,0-0.8,0-1.2c-0.2,0-0.4,0-0.6,0
      c0-0.2,0-0.4,0-0.6c-0.2,0-0.4,0-0.6,0c0,0.2,0,0.4,0,0.6c0.2,0,0.4,0,0.6,0c0,0,0,0,0,0.1c0,0.1,0,0.3,0,0.4c0,0.2,0,0.5,0,0.7
      c0,0,0,0.1,0.1,0.1c0.1,0,0.2,0,0.3,0C-3.4,1.8-3.3,1.8-3.2,1.8z"/>
    <path id="XMLID_172_" fill="#FFFFFF" d="M4.1,4.2C4.1,4.2,4.1,4.2,4.1,4.2c0-0.6,0-1.2,0-1.8c0,0,0,0,0,0c0.2,0,0.4,0,0.6,0
      c0,0,0-0.1,0-0.1c0-1.1,0-2.3,0-3.4c0-0.2,0-0.5,0-0.7c0,0,0-0.1-0.1-0.1c-0.2,0-0.4,0-0.5,0c0,0,0-0.1,0-0.1c0-0.1,0-0.3,0-0.4
      c0,0,0-0.1,0-0.1c-0.2,0-0.4,0-0.6,0c0,0.6,0,1.2,0,1.8c-0.2,0-0.4,0-0.6,0c0-0.8,0-1.6,0-2.4c-0.4,0-0.8,0-1.2,0
      c0,0.6,0,1.2,0,1.8c-0.2,0-0.4,0-0.6,0c0,0,0-0.1,0-0.1c0-0.7,0-1.5,0-2.2c0,0,0-0.1,0-0.1l0,0c0.1,0,0.2,0,0.2,0
      c0.4,0,0.9,0,1.3,0c0.1,0,0.2,0,0.3,0c0,0.2,0,0.4,0,0.6c0.4,0,0.8,0,1.2,0c0,0.2,0,0.4,0,0.6c0.2,0,0.4,0,0.6,0c0,0.2,0,0.4,0,0.6
      c0.2,0,0.4,0,0.6,0c0,1.4,0,2.8,0,4.3c-0.1,0-0.2,0-0.3,0c-0.1,0-0.2,0-0.3,0c0,0.1,0,0.3,0,0.4c0,0.4,0,0.9,0,1.3
      c0,0.1,0,0.1-0.1,0.1C4.5,4.2,4.3,4.2,4.1,4.2L4.1,4.2z"/>
    <path id="XMLID_171_" fill="#FFFFFF" d="M4.1,4.2c0,0.1,0,0.1,0,0.2c0,0.5,0,0.9,0,1.4c0,0.1,0,0.2,0,0.3C2.1,6,0,6-2,6
      c0-0.6,0-1.2,0-1.8c-0.2,0-0.4,0-0.6,0c0-0.4,0-0.8,0-1.2C-2.4,3-2.2,3-2,3c0,0.4,0,0.8,0,1.2c0.2,0,0.4,0,0.6,0c0,0.4,0,0.8,0,1.2
      c1.6,0,3.2,0,4.9,0c0-0.4,0-0.8,0-1.2C3.7,4.2,3.9,4.2,4.1,4.2L4.1,4.2z"/>
    <path id="XMLID_170_" fill="#FFFFFF" d="M-2-6.8c0,0.6,0,1.2,0,1.8c0,1.6,0,3.2,0,4.8c0,0,0,0,0,0.1c-0.2,0-0.4,0-0.6,0
      c0-0.2,0-0.4,0-0.6c-0.2,0-0.4,0-0.6,0c0-0.2,0-0.4,0-0.6l0,0c0.1,0,0.1,0,0.2,0c0.1,0,0.3,0,0.4,0c0-1.8,0-3.6,0-5.5
      c0,0,0.1,0,0.1,0C-2.4-6.8-2.2-6.8-2-6.8C-2.1-6.8-2-6.8-2-6.8L-2-6.8z"/>
    <path id="XMLID_169_" fill="#FFFFFF" d="M1.1-3.7C1-3.7,1-3.7,1.1-3.7c-0.4,0-0.8,0-1.2,0c0,0,0,0-0.1,0c0,0.8,0,1.6,0,2.4
      c-0.2,0-0.4,0-0.6,0c0-1.8,0-3.6,0-5.5c0.2,0,0.4,0,0.6,0c0,0.8,0,1.6,0,2.4c0.4,0,0.8,0,1.2,0c0,0,0,0.1,0,0.1C1-4.1,1-4,1.1-3.7
      C1-3.8,1-3.8,1.1-3.7L1.1-3.7z"/>
    <path id="XMLID_168_" fill="#FFFFFF" d="M-3.2,1.8c-0.1,0-0.2,0-0.3,0c-0.1,0-0.2,0-0.3,0c0,0-0.1,0-0.1-0.1c0-0.2,0-0.5,0-0.7
      c0-0.1,0-0.3,0-0.4c0,0,0,0,0-0.1c-0.2,0-0.4,0-0.6,0c0-0.2,0-0.4,0-0.6c0.2,0,0.4,0,0.6,0c0,0.2,0,0.4,0,0.6c0.2,0,0.4,0,0.6,0
      C-3.2,0.9-3.2,1.3-3.2,1.8c0.2,0,0.4,0,0.6,0c0,0.1,0,0.1,0,0.2c0,0.3,0,0.6,0,1C-2.6,3-2.7,3-2.7,3c-0.2,0-0.3,0-0.5,0
      C-3.2,2.6-3.2,2.2-3.2,1.8z"/>
    <path id="XMLID_167_" fill="#FFFFFF" d="M-3.2-1.3c-0.1,0-0.2,0-0.3,0c-0.3,0-0.5,0-0.8,0c0,0,0,0-0.1,0c0,0.4,0,0.8,0,1.2
      c-0.2,0-0.4,0-0.6,0c0-0.6,0-1.2,0-1.8c0.6,0,1.2,0,1.8,0c0,0.1,0,0.2,0,0.3C-3.2-1.5-3.2-1.4-3.2-1.3L-3.2-1.3z"/>
    <path id="XMLID_166_" fill="#FFFFFF" d="M-2-6.8C-2-7-2-7.2-2-7.4c0.4,0,0.8,0,1.2,0c0,0.2,0,0.4,0,0.6c-0.1,0-0.1,0-0.2,0
      C-1.3-6.8-1.6-6.8-2-6.8C-2-6.8-2-6.8-2-6.8L-2-6.8z"/>
  </g>
</svg>

<dt-article class="centered">
  <h1>What is ANS?</h1>
  <h2>Understanding the new entropy coder: Asymmetric Numeral Systems</h2>
  <dt-byline></dt-byline>
  <p>Recently while attending a talk at the Stanford Compression Forum, I heard about the Asymmetric Numeral Systems entropy coder (ANS). Considering Arithmetic coding and Huffman coding have essentially resolved the problem of entropy coding, I was curious to understand what exactly did this new kid on the block did! However, I found the original paper pretty difficult to follow. Thanks to some amazing and detailed blog posts , I was able to make some sense out of the paper! Today, just a few years after the original paper came out, ANS has already been incorporated into numerous compressors.  So here we go: the ANS Coder is not a single compressor but a class of entropy coders for a given distribution. The most important thing they achieve is achieving very accurate compression (similar to Arithmetic coding), but at very high speeds. This is also seen from Table 1, which lists the improvements due to the usage of the ANS family of entropy coders (like Pied Piper, ANS significantly improves upon the Weissman score :) ). But, why are existing entropy coders slow? </p>

  <h2> Huffman and Arithmetic Coders </h2>
  <p>
  Huffman coding (and for that matter any prefix codes) are the fastest entropy coders, as all they do is table-lookup for encoding and parse a binary tree for decoding [perform experiments and get a number, or lookup into the table]. However, even the most optimal prefix encoder: Huffman coder can be significantly suboptimal. Arithmetic coding is optimal in terms of its compression, but has compression/decompression speeds close to 100 MB/s. These speeds although amazing, are still significantly slower than that of Huffman coding. Also, However, they are slower than the disk access speeds, which implies there is room for resolving this bottleneck (there always is!). If you brush up your memory (or look here: <dt-cite key="gregor2015draw"></dt-cite>) , you would remember that Arithmetic coding subdivides the <i>range</i> which it maintains as a state and thus uses the <i>division</i> operation at every step (both in the encoder and decoder), which is very slow as compared to addition, bit-shifts. The ANS Encoder achieves the optimal compression rate without employing division, some variants of ANS are infact similar to Huffman encoding, as they are "table-lookup" encoders.  
  </p>

 <h2> rANS </h2>
 <p>
 We will first look at one member of the ANS family of coders: <b>rANS</b>, which is an acronym for range-ANS due to its similarities to the arithmetic encoder. Before we describe rANS, some important pointers: 
 <ol>
  <li> Let <dt-math>S = (s_1,s_2,s_3,\ldots, s_n) </dt-math> be the input string of symbols from the alphabet set <dt-math> \mathcal{A} = \{a_1,a_2,\ldots,a_k \}</dt-math> of size <dt-math>k</dt-math>
  <li> We assume the data comes from a distribution characterized by the frequency counts <dt-math> \mathcal{F} = \{ F_{a_1}, F_{a_2},\ldots, F_{a_k} \} </dt-math>, which are integers proportional to the probability mass distribution <dt-math>(p_1,p_2,\ldots,p_k)</dt-math> of the symbols.
    <br>
  Let <dt-math> M = \sum_{i=1}^k F_i </dt-math>. Then, <dt-math> p_i = \frac{F_{a_i}}{M} </dt-math>
  <li> We also define the cumulative frequency counts <dt-math> C_{a_i} = \sum_{j=1}^i F_{a_j} </dt-math>, which correspond to the cumulative distribution of the symbols
  <li> rANS keeps tract of the input using a single integer state. Let <dt-math> X_t </dt-math> represent the integer state of rANS after it has looked at <dt-math> t </dt-math> input symbols. <dt-math> X_0 = 1 </dt-math> is the initial state of rANS. <dt-math> X_t </dt-math> is a function of the previous state <dt-math> X_{t-1} </dt-math> and the current symbol <dt-math> s_t </dt-math>
    <dt-math block>  X_t = C_{rANS}(X_{t-1},s_t)</dt-math>
  <li> The state <dt-math> X_n </dt-math> (along with the number of symbols encoded: <dt-math> n </dt-math>) is used to decode the entire input string <dt-math> S </dt-math>
    <dt-math block>  s_t, X_{t-1} = D_{rANS}(X_{t})</dt-math>
 </ol>
 </p>
  <p>
   To clear off some confusion, consider the following example: For the binary alphabet <dt-math> \mathcal{A} = \{ A,B\} </dt-math>, we can consider input generated using frequency counts <dt-math> F = \{ 3, 1\} </dt-math>, which corresponds to probabilities <dt-math> \{ \frac{3}{4}, \frac{1}{4} \} </dt-math>. Note that rANS keeps track of a single integer state, unlike the vanilla Arithmetic encoder, which needs to keep track of two floating-point states during the computation. 
  </p>

   <h3> rANS Encoding & Decoding </h3>
   <p>
   We are now all set to describe the rANS encoding. We will first describe the encoding and decoding functions in their full glory, and then try to understand their operations using simple examples. So here it goes: 
   </p>
  <p>

   <dt-math block> 
      X_t = floor \left( \frac{X_{t-1}}{F_{s_t}} \right) * M + C_{s_t} + mod(X_{t-1}, F_{s_t}) 
   </dt-math>
    
   Thats all! This is the encoding step for the rANS. We also present a python function script (which is more of a pseudo-code) to play around with. 

   <dt-code block language="python">
  # rANS Encoder code. Not optimized in any way
  # Mainly for playing around 
  def rANS_encoder(s_input, symbol_counts):
    total_counts = np.sum(symbol_counts)  #Represents M
    cumul_sum = np.insert(np.cumsum(symbol_counts),0,0) #Cumul_sum represents the cumulative frequencies
    num_symbols = len(s_input) #the length of the input
    
    state = 1 #Initialize the state
    for s in s_input:
      s_count = symbol_counts[s] #current symbol count/frequency
      state = (state/s_count)*total_counts + cumul_sum[s] + (state % s_count) #Main encoding step

    return state, num_symbols
   </dt-code>

   Lets also state the decoder for completeness. 
   Let <dt-math> C\_inv(y) </dt-math> be the inverse function of the cumulative frequency, where: <dt-math> C\_inv(y) = a_i </dt-math>, if <dt-math> C_{a_i} \leq y  < C_{a_{i+1}} </dt-math>. Then, the decoder, <dt-math>D_{rANS}(X_{t})</dt-math> is defined as follows:

   <dt-math block> 
      \begin{aligned}
      slot &= mod(X_t,M) \\
      s_t  &= C\_inv(slot) \\
      X_{t-1} &= floor \left( X_t/M \right) * F_{s_t} + slot - C_{s_t} 
      \end{aligned}
   </dt-math>

   Also find the code snipped for decoding below:
   <dt-code block language="python">
  #rANS Decoder code. Not optimized in any way
  #Mainly for playing around 
  def rANS_decoder(state, num_symbols, symbol_counts):
    total_counts = np.sum(symbol_counts)  #Represents M
    cumul_sum = np.insert(np.cumsum(symbol_counts),0,0) #Cumul_sum represents the cumulative frequencies

    #The Cumulative frequency inverse function
    def cumul_inverse(y): 
      for i,_s in enumerate(cumul_sum): 
        if y < _s: return i-1

    s_decoded = []  #Initialize a list to hold the decoded symbols
    while len(s_decoded) < num_symbols: #continue decoding until all symbols decoded
      slot = state % total_counts #compute the slot     
      s = cumul_inverse(y) #decode the symbol
      s_decoded.append(s) 
      state = (state/total_counts)*symbol_count[s] + slot - cumul_sum[s] #update the state

    return x_decoded
   </dt-code>

  
  </p>

   <h4> Example 1</h4>
   <p> 
   Lets consider a simple example over 3 alphabets, with frequency counts: <dt-math> \mathcal{F} = \{ 1,1,1\} </dt-math>. How does the encoding of the string <dt-math> S = \{ 0,2,1,1,0,2,2\} </dt-math> look?

   <dt-code block language="python">
   # The state at every stage of encoding
   X_0 = 1 
   X_1 = 1*3 + 0 + 0 = 3 
   X_2 = 3*3 + 2 + 0 = 11 
   X_3 = 11*3 + 1 + 0 = 34 
   ...
   X_7 = 
   </dt-code>

   The example is pretty simple, but intuitively it makes things clear. We can represent  
   </p>


  <p>We can also cite <dt-cite key="gregor2015draw"></dt-cite> external publications.</p>
</dt-article>

<dt-appendix>
</dt-appendix>

<script type="text/bibliography">
  @article{gregor2015draw,
    title={DRAW: A recurrent neural network for image generation},
    author={Gregor, Karol and Danihelka, Ivo and Graves, Alex and Rezende, Danilo Jimenez and Wierstra, Daan},
    journal={arXivreprint arXiv:1502.04623},
    year={2015},
    url={https://arxiv.org/pdf/1502.04623.pdf}
  }
</script>